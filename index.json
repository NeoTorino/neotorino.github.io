[{"categories":["Rust"],"content":"To run it: rustc list_files.rs -o list_files ./list_files /path/to/directory list_files.rs use std::env; use std::fs; use std::path::Path; fn main() { let args: Vec\u003cString\u003e = env::args().collect(); if args.len() != 2 { eprintln!(\"Usage: {} \u003cdirectory_path\u003e\", args[0]); std::process::exit(1); } let path = Path::new(\u0026args[1]); if !path.is_dir() { eprintln!(\"Error: {} is not a directory\", path.display()); std::process::exit(1); } match fs::read_dir(path) { Ok(entries) =\u003e { println!(\"Listing files in directory: {}\", path.display()); for entry in entries { match entry { Ok(entry) =\u003e { println!(\"{}\", entry.file_name().to_string_lossy()); } Err(e) =\u003e { eprintln!(\"Error reading entry: {}\", e); } } } } Err(e) =\u003e { eprintln!(\"Error opening directory: {}\", e); std::process::exit(1); } } } ","date":"2025-04-27","objectID":"/rust/:0:0","tags":null,"title":"Rust","uri":"/rust/"},{"categories":["Assembly"],"content":"; Calculate the Fibonacci number using recursion ; fib(n) = fib(n-1) + fib(n-2) lib.asm %include \"constants.asm\" section .data section .bss ;buffer resb 255 ; reserverd 255 bytes section .text ; ----------------------------------------------------------------------------- ; Calculate the length of a string in rsi. ; The string can end in LF (\\n) or NUL (\\0) ; Input: ; rsi points to string ; Output: ; rax contains length. ; Error: ; rax returns -1 _fn_strlen: xor rax, rax ; clear rax _fn_strlen_loop: cmp BYTE [rsi + rax], 0x0A ; compare with LF '\\n' je _fn_strlen_break cmp BYTE [rsi + rax], 0x00 ; compare with NUL '\\0' je _fn_strlen_break inc rax jmp _fn_strlen_loop _fn_strlen_break: ret _fn_strlen_error: xor rax, rax ; set to 0 (all 0s) not rax ; invert (all 1s) ret ; ----------------------------------------------------------------------------- ; ; Convert string of numbers to integer ; Input: ; rsi points to the string of numbers ending in '\\n' ; Output: ; rcx contains the integer representation ; Error: ; rax equals 1 ; Modifies: ; rax, rbx, r8 ; Dependencies: ; _fn_strlen, to calculate the length of the string ; _fn_exit, to exit if error _fn_str2int: xor rbx, rbx ; clear rbx, to store the decimal part xor rcx, rcx ; clear rcx, to store the final number mov r8, 0x0A ; base 10 _fn_str2int_init: ; Input rsi points to string ; Output rax contains length ; Modifies rax call _fn_strlen ; calculate the length of the string cmp al, 0 ; exit function if length = 0 je _fn_str2int_end cmp al, -1 je _fn_str2int_err mov rdx, rax ; copy the length from rax to rdx mov rax, 0x01 ; put 1 in rax _fn_str2int_base: ; create base 10 position dec dl cmp dl, 0 jle _fn_str2int_decimal imul rax, r8 jmp _fn_str2int_base _fn_str2int_decimal: mov bl, byte [rsi] cmp bl, 0x30 ; compare with num. 0 jl _fn_str2int_err ; if not an integer go to erro cmp bl, 0x39 ; compare with num. 9 jg _fn_str2int_err ; if not an integer go to error sub bl, 0x30 ; to get integer representation ; from a char number in ASCII mul rbx ; add the integer part add rcx, rax ; store decimal value inc rsi jmp _fn_str2int_init _fn_str2int_end: ret _fn_str2int_err: mov rax, 0x01 ; error code = 1 ret ; ----------------------------------------------------------------------------- ; ; Convert an integer to string ; Input: ; rax contains the integer to convert to string ; Output: ; rsi points to the string ; rdx contains the length of the string ; Error: ; rax equals 1 ; Modifies: ; rax, rcx ; Dependencies: ; _fn_strlen, to calculate the length of the string ; _fn_exit, to exit if error ; Notes: ; - Division: ; - Byte/Byte: The nominator resides in the AL register and AH is set to zero. After division, ; the instruction stores quotient in AL and the remainder in AH register. ; - Word/Word: The AX register holds the numerator. After division, the quotient is stored in ; the AX register and the remainder goes to the DX register. ; - Word/Byte: The numerator is a 16-bit word stored in AX which is divided with an 8-bit ; denominator. After division, the AL contains the quotient and AH will contain ; the remainder. ; - Double Word/Word: AX and DX stores the numerator. The most significant part resides in ; the DX register and the least significant bits of numerator are in the AX register. ; After the execution of DIV instruction, the remainder goes to DX register ; and the quotient lie in AX register. _fn_int2str: mov rbx, 0x0A ; Put 10 in rbx xor rcx, rcx ; clear rcx, to store the legnth xor rdx, rdx ; clear rdx, to store the reminder for word or double word division _fn_int2str_init: cmp rax, rbx ; check if number is smaller than the base jl _fn_int2str_end ; end if smaller than base div rbx ; rax = rax / rbx, rdx = rax % rbx add dl, 0x30 ; convert reminder to string in ASCII push rdx ; push rdx to the stack inc cl ; increment length jmp _fn_int2str_init ; start again _fn_int2str_end: add al, 0x30 ; convert num to string push rax inc cl ; increment string length mov al, 0x0A ; store LF '\\n","date":"2025-04-27","objectID":"/assesmbly/:0:0","tags":["nasm"],"title":"Assembly","uri":"/assesmbly/"},{"categories":["c"],"content":"To compile run: gcc list_files.c -o list_files ./list_files /path/to/directory list_files.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cdirent.h\u003e #include \u003cstring.h\u003e int main(int argc, char *argv[]) { struct dirent *de; // Pointer for directory entry DIR *dr; if (argc != 2) { printf(\"Usage: %s \u003cdirectory_path\u003e\\n\", argv[0]); return 1; } // Open the directory dr = opendir(argv[1]); if (dr == NULL) { perror(\"Could not open directory\"); return 1; } printf(\"Listing files in directory: %s\\n\", argv[1]); while ((de = readdir(dr)) != NULL) { printf(\"%s\\n\", de-\u003ed_name); } closedir(dr); return 0; } ","date":"2025-04-26","objectID":"/c/:0:0","tags":[],"title":"C","uri":"/c/"},{"categories":["Shell"],"content":" Name Path FreeBSD Bourne shell /bin/sh Installed Cshell /bin/csh Installed TENEX C shell /bin/tcsh Installed Bourne-again shell /path/to/bin/bash Available Z shell /path/to/bin/zsh Available Korn shell /path/to/bin/kcsh Available ","date":"2025-04-26","objectID":"/shells/:0:0","tags":["sh","csh","tcsh","bash","zsh","kcsh"],"title":"Shells","uri":"/shells/"},{"categories":["Shell"],"content":"Print 1 to 5\" script ","date":"2025-04-26","objectID":"/shells/:1:0","tags":["sh","csh","tcsh","bash","zsh","kcsh"],"title":"Shells","uri":"/shells/"},{"categories":["Shell"],"content":"Bourne shell (sh) #!/bin/sh echo \"Bourne shell loop:\" i=1 while [ $i -le 5 ] do echo \"Number: $i\" i=`expr $i + 1` done This uses traditional Bourne syntax: while, test [ ], expr for arithmetic. ","date":"2025-04-26","objectID":"/shells/:1:1","tags":["sh","csh","tcsh","bash","zsh","kcsh"],"title":"Shells","uri":"/shells/"},{"categories":["Shell"],"content":"Cshell (csh) #!/bin/csh echo \"C shell loop:\" set i = 1 while ( $i \u003c= 5 ) echo \"Number: $i\" @ i = $i + 1 end In csh, variables use set, and arithmetic uses @. Also, conditions are in parentheses () instead of brackets []. ","date":"2025-04-26","objectID":"/shells/:1:2","tags":["sh","csh","tcsh","bash","zsh","kcsh"],"title":"Shells","uri":"/shells/"},{"categories":["Shell"],"content":"TENEX C shell #!/bin/tcsh echo \"TENEX C shell loop:\" set i = 1 while ( $i \u003c= 5 ) echo \"Number: $i\" @ i = $i + 1 end This is almost identical to csh, because tcsh is a compatible superset of csh. However, tcsh allows you to use nicer editing, filename completion, and better scripting practices if needed. #!/bin/tcsh echo \"TENEX C shell foreach loop:\" foreach i (1 2 3 4 5) echo \"Number: $i\" end A slightly more tcsh-style version (using foreach, which is a little cleaner) ","date":"2025-04-26","objectID":"/shells/:1:3","tags":["sh","csh","tcsh","bash","zsh","kcsh"],"title":"Shells","uri":"/shells/"}]